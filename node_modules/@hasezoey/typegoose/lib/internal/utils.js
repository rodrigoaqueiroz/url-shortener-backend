"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const data_1 = require("./data");
const primitives = ['String', 'Number', 'Boolean', 'Date', 'Decimal128', 'ObjectID', 'Array'];
/**
 * Returns true, if it includes the Type
 * @param Type The Type
 * @returns true, if it includes it
 */
function isPrimitive(Type) {
    return primitives.includes(Type.name);
}
exports.isPrimitive = isPrimitive;
/**
 * Returns true, if it is an Object
 * @param Type The Type
 * @returns true, if it is an Object
 */
function isObject(Type) {
    let prototype = Type.prototype;
    let name = Type.name;
    while (name) {
        if (name === 'Object') {
            return true;
        }
        prototype = Object.getPrototypeOf(prototype);
        name = prototype ? prototype.constructor.name : null;
    }
    return false; // can this even return false?
    // return !isNullOrUndefined(Type) && (typeof Type === 'object' || Type.name === 'Object') && !Array.isArray(Type);
}
exports.isObject = isObject;
/**
 * Returns true, if it is an Number
 * @param Type The Type
 * @returns true, if it is an Number
 */
function isNumber(Type) {
    return Type.name === 'Number';
}
exports.isNumber = isNumber;
/**
 * Returns true, if it is an String
 * @param Type The Type
 * @returns true, if it is an String
 */
function isString(Type) {
    return Type.name === 'String';
}
exports.isString = isString;
/**
 * Initialize as Object
 * @param name The Name of the Schema
 * @param key The Property key to set
 */
function initAsObject(name, key) {
    if (!data_1.schemas.get(name)) {
        data_1.schemas.set(name, {});
    }
    data_1.schemas.get(name)[key] = {};
}
exports.initAsObject = initAsObject;
/**
 * Initialize as Array
 * @param name The Name of the Schema
 * @param key The Property key to set
 */
function initAsArray(name, key) {
    if (!data_1.schemas.get(name)) {
        data_1.schemas.set(name, {});
    }
    data_1.schemas.get(name)[key] = [{}];
}
exports.initAsArray = initAsArray;
/**
 * Get the Class for a given Document
 * @param document The Document
 */
function getClassForDocument(document) {
    const modelName = document.constructor.modelName;
    return data_1.constructors.get(modelName);
}
exports.getClassForDocument = getClassForDocument;
/**
 * Return true if there are Options
 * @param options The raw Options
 */
function isWithStringValidate(options) {
    return !util_1.isNullOrUndefined(options.match
        || options.enum
        || options.minlength
        || options.maxlength);
}
exports.isWithStringValidate = isWithStringValidate;
/**
 * Return true if there are Options
 * @param options The raw Options
 */
function isWithStringTransform(options) {
    return !util_1.isNullOrUndefined(options.lowercase || options.uppercase || options.trim);
}
exports.isWithStringTransform = isWithStringTransform;
/**
 * Return true if there are Options
 * @param options The raw Options
 */
function isWithNumberValidate(options) {
    return !util_1.isNullOrUndefined(options.min || options.max);
}
exports.isWithNumberValidate = isWithNumberValidate;
const virtualOptions = ['localField', 'foreignField'];
/**
 * Check if Options include Virtual Populate Options
 * @param options RawOptions of the Prop
 */
function isWithVirtualPOP(options) {
    return Object.keys(options).some((v) => virtualOptions.includes(v));
}
exports.isWithVirtualPOP = isWithVirtualPOP;
exports.allVirtualoptions = virtualOptions.slice(0);
exports.allVirtualoptions.push('ref');
/**
 * Check if All the required Options are present
 * @param options RawOptions of the Prop
 */
function includesAllVirtualPOP(options) {
    return exports.allVirtualoptions.every((v) => Object.keys(options).includes(v));
}
exports.includesAllVirtualPOP = includesAllVirtualPOP;
/**
 * Check if the given value has options of "IModelOptions"
 * @param value The Value to evaulate
 * @internal
 */
function isModelOptions(value) {
    return value && (typeof value.schemaOptions === 'object' ||
        typeof value.options === 'object');
}
/**
 * Merges existing metadata with new value
 * @param key Metadata key
 * @param value Raw value
 * @param cl The constructor
 * @internal
 */
function assignMetadata(key, value, cl) {
    const current = Reflect.getMetadata(key, cl) || {};
    // the following checks are needed, so that the new value dosnt override the full options
    // "deepmerge" cannot be used because of the other options like "existingMongoose"
    if (isModelOptions(value) && !util_1.isNullOrUndefined(current.schemaOptions)) {
        value.schemaOptions = Object.assign(current.schemaOptions, value.schemaOptions);
    }
    if (isModelOptions(value) && !util_1.isNullOrUndefined(current.options)) {
        value.options = Object.assign(current.options, value.options);
    }
    const newValue = Object.assign(current, value);
    Reflect.defineMetadata(key, newValue, cl);
}
exports.assignMetadata = assignMetadata;
/**
 * Get the correct name of the class's model
 * (with suffix)
 * @param cl The Class
 */
function getName(cl) {
    // disabled until hasezoey#23 & hasezoey#24 gets fixed
    // const options: IModelOptions = Reflect.getMetadata(DecoratorKeys.ModelOptions, cl) || {};
    // const baseName = cl.name;
    // const suffix = (options.options ? options.options.customName : undefined) ||
    //   (options.schemaOptions ? options.schemaOptions.collection : undefined);
    // return suffix ? `${baseName}_${suffix}` : baseName;
    return cl.name;
}
exports.getName = getName;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW50ZXJuYWwvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQSwrQkFBeUM7QUFVekMsaUNBQStDO0FBRS9DLE1BQU0sVUFBVSxHQUFHLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFFOUY7Ozs7R0FJRztBQUNILFNBQWdCLFdBQVcsQ0FBQyxJQUFTO0lBQ25DLE9BQU8sVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDeEMsQ0FBQztBQUZELGtDQUVDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLFFBQVEsQ0FBQyxJQUFTO0lBQ2hDLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDL0IsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztJQUNyQixPQUFPLElBQUksRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUNyQixPQUFPLElBQUksQ0FBQztTQUNiO1FBQ0QsU0FBUyxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDN0MsSUFBSSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztLQUN0RDtJQUVELE9BQU8sS0FBSyxDQUFDLENBQUMsOEJBQThCO0lBQzVDLG1IQUFtSDtBQUNySCxDQUFDO0FBYkQsNEJBYUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IsUUFBUSxDQUFDLElBQVM7SUFDaEMsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQztBQUNoQyxDQUFDO0FBRkQsNEJBRUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IsUUFBUSxDQUFD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